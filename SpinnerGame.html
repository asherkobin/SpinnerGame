<!doctype html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"/>
        <title>Sandbox</title>
    </head>
    <script>
        window.addEventListener("load", (e) => { init(); });
        
        function init() {
            const output = document.getElementById("output");
            output.innerText = "Loaded OK";

            const button = document.getElementById("button");
            const debug_button = document.getElementById("debug_button");
            button.addEventListener("click", (e) => { connectToController(); });
            debug_button.addEventListener("click", (e) => { debug_button_click(); });
        }

        function connectToController() {
            const service_uid = "00001623-1212-efde-1623-785feabcd123";
            const characteristic_uid = "00001624-1212-efde-1623-785feabcd123";
            const setup_data = new Uint8Array([10, 0, 0x41, 0, 0x04, 1, 0, 0, 0, 1]);
            
            // 10   => Size
            // 0    => Hub 0
            // 0x41 => Message Type - Port Input Format Setup (Single) [0x41]
            // 1    => BOTH BUTTONS = 1 (LEFT ONLY = 0)
            // 0x04 => REMOTE_BUTTONS_MODE_KEYSD = 4
            // 1    => DELTA_INTERVAL = 1 (4 BYTES)
            // 1    => ENABLE_NOTIFICATIONS
            
            navigator.bluetooth.requestDevice({
                filters: [{ name: "Handset"}],
                optionalServices: [service_uid] })
                .then(device => device.gatt.connect())
                .then(server => server.getPrimaryService(service_uid))
                .then(service => service.getCharacteristic(characteristic_uid))
                .then(characteristic => {
                    characteristic.writeValueWithResponse(setup_data)
                        .then(response => {
                            characteristic.startNotifications();
                        })
                        .then(() => {
                            characteristic.addEventListener("characteristicvaluechanged", change_handler)
                            output.innerText = "Listening..."
                        })
                })
                .catch(e => { output.innerText = e; });
        }

        var button_state = {
            left_plus: false,
            left_stop: false,
            left_minus: false,
            center: false,
            right_plus: false,
            right_stop: false,
            right_minus: false
        };

        function change_handler(e) {
            const data = e.target.value.buffer ? e.target.value : new DataView(e.target.value);
            let button_state_changed = false;

            if (data.getUint8(0) == 5) {
                if (data.getUint8(2) == 0x08) { // LWP3_MSG_TYPE_HW_NET_CMDS
                    button_state.center = data.getUint8(4) == 1;
                    button_state_changed = true;
                }
            }
            else if (data.getUint8(0) == 7) {
                if (data.getUint8(2) == 0x45) { // LWP3_MSG_TYPE_PORT_VALUE
                    if (data.getUint8(3) == 0) { // LEFT
                        button_state.left_plus = data.getUint8(4) == 1;
                        button_state.left_stop = data.getUint8(5) == 1;
                        button_state.left_minus = data.getUint8(6) == 1;
                        button_state_changed = true;
                    }
                    else if (data.getUint8(3) == 1) { // RIGHT
                        button_state.right_plus = data.getUint8(4) == 1;
                        button_state.right_stop = data.getUint8(5) == 1;
                        button_state.right_minus = data.getUint8(6) == 1;
                        button_state_changed = true;
                    }
                }
            }
            else {
                console.log("Unhandled Event: " + data)
            }

            if (button_state_changed) {
                handleInput(button_state);
            }
        }
    </script>
    <style>
        .button {
            background-color: #404040;
            color: lightgray;
            padding: 15px 32px;
            font-size: 16px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            text-align: center;
            display: inline-block;
            transition: background-color 0.3s ease;
        }
        .button:hover {
            background-color: #606060; 
        }
        .button:active {
            background-color: #808080;
        }
        .output {
            border: 2px solid black;
            margin-top: 5px;
            margin-bottom: 5px;
            display: none;
        }
        canvas {
            display: block;
            border: 1px solid black;
        }
    </style>
    <body>
        <button id="button" class="button">Connect</button>
        <div id="output" class="output">YOU SHOULD NOT BE SEEING THIS!</div>
        <canvas id="canvas" width="350" height="640"></canvas>
        <button id="debug_button" class="button" style="display: none;">Debug</button> 
    </body>
    <script>
        function drawLockFace(c, li, s) {
            c.save();
            c.translate(li.x, li.y);
            
            // background
            let bgGradient = c.createRadialGradient(0, 0, li.r * 0.3, 0, 0, li.r);

            bgGradient.addColorStop(0, "#f6d57a");  // light brass
            bgGradient.addColorStop(0.5, "#d4a73b");
            bgGradient.addColorStop(1, "#8c6b1f");  // dark brass edge

            c.beginPath();
            c.arc(0, 0, li.r, 0, Math.PI * 2);
            c.fillStyle = bgGradient;
            c.fill();
            
            c.lineWidth = li.r * 0.05;
            c.strokeStyle = "#6f5418";
            c.stroke();
            
            // plug
            let plugRadius = li.r * 0.70;
            let plugGradient = c.createRadialGradient(0, 0, 0, 0, 0, plugRadius);
            
            plugGradient.addColorStop(0, "#f1c861");
            plugGradient.addColorStop(0.7, "#c9982f");
            plugGradient.addColorStop(1, "#7a5c1a");

            c.beginPath();
            c.arc(0, 0, plugRadius, 0, Math.PI * 2);
            c.fillStyle = plugGradient;
            c.fill();

            c.lineWidth = li.r * 0.02;
            c.strokeStyle = "#5f4714";
            c.stroke();

            // tick marks
            let tickCount = 12;

            c.save();
            c.rotate(s.tumblerAngle);
            
            for (let i = 0; i < tickCount; i++) {
                let tickAngle = (i / tickCount) * 2 * Math.PI;
                let innerRadius = li.r * 0.85;
                let outerRadius = li.r * 0.95;

                c.save();
                c.rotate(tickAngle);
                c.beginPath();
                c.moveTo(0, innerRadius);
                c.lineTo(0, outerRadius);
                c.strokeStyle = "#6e5418";
                c.lineWidth = li.r * 0.015;
                c.stroke();
                c.restore();
            }

            c.restore();

            // keyway
            
            c.save();
            c.translate(-8, -38); // convert to percentage
            c.scale(0.7, 0.7)
            drawKeyway(c, li);
            c.restore();

            c.restore();
        }

        function drawKeyway(c, li) {
            c.beginPath();

            c.moveTo(0, 0);
            c.lineTo(15, 0);
            c.lineTo(15, 50);
            c.lineTo(25, 60);
            c.lineTo(25, 70);
            c.lineTo(15, 75);
            c.lineTo(15, 85);
            c.lineTo(25, 85);
            c.lineTo(25, 110);
            c.lineTo(0, 110);
            c.lineTo(0, 65);
            c.lineTo(5, 65);
            c.lineTo(5, 55);
            c.lineTo(0, 50);
            c.lineTo(0, 0);

            c.lineWidth = 2;
            c.strokeStyle = "black";
            c.stroke();

            c.fillStyle = "#1a1a1a";
            c.fill();

            c.lineWidth = c.r * 0.01;
            c.strokeStyle = "#333";
            c.stroke();
        }

        function drawTumbler(c, li, s) {
            const startAngle = s.tumblerAngle + li.pw / 2 - li.pp;
            const endAngle = startAngle + (2 * Math.PI - li.pw - 2 * li.pp);

            c.beginPath();
            c.arc(li.x, li.y, li.r + li.t, startAngle, endAngle, false);
            c.arc(li.x, li.y, li.r, endAngle, startAngle, true);
            c.closePath();
            
            c.lineWidth = 2;
            c.strokeStyle = "#5f4714";
            c.stroke();

            const tumblerGradient = c.createRadialGradient(0, 0, 0, 0, li.r, li.r + li.t);
            
            tumblerGradient.addColorStop(0, "#f1c861");
            tumblerGradient.addColorStop(0.7, "#c9982f");
            tumblerGradient.addColorStop(1, "#7a5c1a");

            c.fillStyle = tumblerGradient;
            c.fill();
           
            c.beginPath();
            c.arc(li.x, li.y, li.r + li.t + 1, 0, Math.PI * 2);
            c.lineWidth = 4;
            c.strokeStyle = "rgba(255,255,255,0.25)";
            c.stroke();
        }
    </script>
    <script>
    
        let keyPinCenterX = 0;//tumblerCenterX;
        let keyPinCenterY = 0;//tumblerCenterY;
        const keyPinThickness = 20;
        const keyPinAngle = Math.PI / 180 * 25;
        const keyPinPaddingAngle = Math.PI / 180;
        let keyPinDegrees = 0;

        let leftKeyDown = false;
        let rightKeyDown = false;
        let upKeyDown = false;
        let downKeyDown = false;

        function drawKeyPin(c, li, s) { 
            let keyPinInnerRadius = tumblerInnerRadius + tumblerThickness + tumblerKeyPinSpacing;
            let keyPinOuterRadius = keyPinInnerRadius + keyPinThickness;
            let keyPinMiss = false;

            if (upKeyDown) {
                if (!keyPinInCut) {
                    if (angleDistance(tumblerDegrees, keyPinDegrees) < matchTolerance) {
                        keyPinInCut = true;
                    }
                    else {
                        keyPinMiss = true;
                    }
                }
                else {
                    keyPinInCut = false;
                }

                upKeyDown = false;
            }

            if (downKeyDown && keyPinInCut) {
                keyPinInCut = false;
                keyPinDegrees = tumblerDegrees
            }

            if (leftKeyDown) {
                keyPinDegrees = normalizeDegrees(keyPinDegrees + 5);
            }
            else if (rightKeyDown) {    
                keyPinDegrees = normalizeDegrees(keyPinDegrees - 5);
            }

            if (keyPinInCut) {
                keyPinOuterRadius = tumblerInnerRadius + tumblerThickness;
                keyPinInnerRadius = keyPinOuterRadius - keyPinThickness;
                
                keyPinDegrees = tumblerDegrees;
            }
            
            let startDegrees = normalizeDegrees(keyPinDegrees - keyPinWidthDegrees / 2 - keyPinPaddingDegrees);
            let endDegrees = normalizeDegrees(startDegrees + keyPinWidthDegrees - 2 * keyPinPaddingDegrees);

            if (keyPinMiss) {
                fillColor = "red";
            }
            else if (keyPinInCut) {
                fillColor = "green";
            }
            else {
                fillColor = "yellow";
            }
            
            c.beginPath();
            c.arc(keyPinCenterX, keyPinCenterY, keyPinOuterRadius, degreesToRadians(startDegrees), degreesToRadians(endDegrees), false);
            c.arc(keyPinCenterX, keyPinCenterY, keyPinInnerRadius, degreesToRadians(endDegrees), degreesToRadians(startDegrees), true);
            c.fillStyle = fillColor;
            c.fill();
            c.closePath();
        }

        function drawButton(c, li, s) {
            if (s.tumblerSpinning) {
                li.buttonInfo.fillColor = li.buttonInfo.stopFillColor;
                li.buttonInfo.text = "STOP";
            }
            else {
                li.buttonInfo.fillColor = li.buttonInfo.startFillColor;
                li.buttonInfo.text = "START";
            }
            
            c.fillStyle = li.buttonInfo.fillColor;
            c.fillRect(li.buttonInfo.x, li.buttonInfo.y, li.buttonInfo.width, li.buttonInfo.height);

            if (li.buttonInfo.drawBorder) {
                c.lineWidth = 1;
                c.strokeStyle = li.buttonInfo.borderColor;
                c.strokeRect(li.buttonInfo.x, li.buttonInfo.y, li.buttonInfo.width, li.buttonInfo.height);
            }

            c.fillStyle = li.buttonInfo.fontColor;
            c.font = "16px Arial";
            c.textAlign = "center";
            c.textBaseline = "middle";
            c.fillText(li.buttonInfo.text, 1 + li.buttonInfo.x + li.buttonInfo.width / 2, 2 + li.buttonInfo.y + li.buttonInfo.height / 2);
            c.closePath();
        }

        function drawBackground(c, li, s) {
            const bgGradient = c.createRadialGradient(li.x, li.y, 0, li.x, li.y, li.w);

            bgGradient.addColorStop(0, "#1a1a1a");
            bgGradient.addColorStop(1, "#050505");

            c.fillStyle = bgGradient;
            c.fillRect(0, 0, li.w, li.h);
        }

        function startGame(htmlDoc) {
            const canvas = htmlDoc.getElementById("canvas");
            const canvasContext = canvas.getContext("2d");
            const layoutInfo = {
                w: canvas.width,
                h: canvas.height,
                x: canvas.width / 2,
                y: canvas.height / 2,
                r: 75,
                t: 60,
                pw: keyPinAngle,
                pp: keyPinPaddingAngle,
                buttonInfo: {
                    x: canvas.width / 2 - 75 / 2,
                    y: canvas.height / 2 - 75 / 2 + 250,
                    width: 75,
                    height: 75,
                    drawBorder: false,
                    stopFillColor: "darkred",
                    startFillColor: "darkgreen",
                    fontColor: "lightgray",
                    borderColor: "black"
                }
            };
            const gameState = {
                tumblerAngle: 0,
                tumblerSpinning: false,
                keyPinInCut: false,
                buttonSize: 60,
                rightKeyDown: false,
                leftKeyDown: false,
                upKeyDown: false,
                downKeyDown: false
            };
            const gameConfig = {
                msPerRadian: 500,
                matchTolerance: 15 * Math.PI / 180,
            }
            const eventHandlers = {
                keyDown: (e) => {
                    if (e.key == "ArrowRight") {
                        gameState.rightKeyDown = true;
                    }
                    else if (e.key == "ArrowLeft") {
                        gameState.leftKeyDown = true;
                    }
                    else if (e.key == "ArrowUp") {
                        gameState.upKeyDown = true;
                    }
                    else if (e.key == "ArrowDown") {
                        gameState.downKeyDown = true;
                    }
                },
                keyUp: (e) => {
                    if (e.key == "ArrowRight") {
                        gameState.rightKeyDown = false;
                    }
                    else if (e.key == "ArrowLeft") {
                        gameState.leftKeyDown = false;
                    }
                    else if (e.key == "ArrowUp") {
                        gameState.upKeyDown = false;
                    }
                    else if (e.key == "ArrowDown") {
                        gameState.downKeyDown = false;
                    }
                },
                mouseMove: (e) => {
                    const canvasRect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - canvasRect.left;
                    const mouseY = e.clientY - canvasRect.top;

                    layoutInfo.buttonInfo.drawBorder = eventHandlers.isPointInButton(mouseX, mouseY);
                },
                mouseClick: (e) => {
                    const canvasRect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - canvasRect.left;
                    const mouseY = e.clientY - canvasRect.top;

                    if (eventHandlers.isPointInButton(mouseX, mouseY)) {
                        gameState.tumblerSpinning = !gameState.tumblerSpinning;
                    }
                },
                isPointInButton: (x, y) => {
                    return x >= layoutInfo.buttonInfo.x && x <= layoutInfo.buttonInfo.x + layoutInfo.buttonInfo.width &&
                        y >= layoutInfo.buttonInfo.y && y <= layoutInfo.buttonInfo.y + layoutInfo.buttonInfo.height; 
                }
            };

            htmlDoc.addEventListener("keydown", eventHandlers.keyDown);
            htmlDoc.addEventListener("keyup", eventHandlers.keyUp);
            htmlDoc.addEventListener("mousemove", eventHandlers.mouseMove);
            htmlDoc.addEventListener("click", eventHandlers.mouseClick);

            const spinTumbler = (timeStamp) => {
                const deltaTime = timeStamp - gameState.lastTime;
                
                gameState.lastTime = timeStamp;

                if (gameState.tumblerSpinning) {
                    gameState.tumblerAngle = gameState.tumblerAngle + deltaTime / gameConfig.msPerRadian;
                }

                drawFrame();
                requestAnimationFrame(spinTumbler);
            }

            const drawFrame = () => {
                drawBackground(canvasContext, layoutInfo, gameState);
                drawLockFace(canvasContext, layoutInfo, gameState);
                drawTumbler(canvasContext, layoutInfo, gameState);
                //drawKeyPin(canvasContext);
                drawButton(canvasContext, layoutInfo, gameState);
            }

            spinTumbler();
        }

        function handleInput(button_state) {
            if (button_state.center) {
                handleButtonClick();
            }

            leftKeyDown = button_state.left_plus;
            rightKeyDown = button_state.left_minus;
            upKeyDown = button_state.left_stop;
        }

        startGame(document);
    </script>
</html>