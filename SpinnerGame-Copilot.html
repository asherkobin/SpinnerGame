<!doctype html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"/>
        <title>Sandbox</title>
    </head>
    <script>
        window.addEventListener("load", (e) => { init(); });
        
        function init() {
            const output = document.getElementById("output");
            output.innerText = "Loaded OK";

            const button = document.getElementById("button");
            const debug_button = document.getElementById("debug_button");
            button.addEventListener("click", (e) => { connectToController(); });
            debug_button.addEventListener("click", (e) => { debug_button_click(); });
        }

        function connectToController() {
            const service_uid = "00001623-1212-efde-1623-785feabcd123";
            const characteristic_uid = "00001624-1212-efde-1623-785feabcd123";
            const setup_data = new Uint8Array([10, 0, 0x41, 0, 0x04, 1, 0, 0, 0, 1]);
            
            // 10   => Size
            // 0    => Hub 0
            // 0x41 => Message Type - Port Input Format Setup (Single) [0x41]
            // 1    => BOTH BUTTONS = 1 (LEFT ONLY = 0)
            // 0x04 => REMOTE_BUTTONS_MODE_KEYSD = 4
            // 1    => DELTA_INTERVAL = 1 (4 BYTES)
            // 1    => ENABLE_NOTIFICATIONS
            
            navigator.bluetooth.requestDevice({
                filters: [{ name: "Handset"}],
                optionalServices: [service_uid] })
                .then(device => device.gatt.connect())
                .then(server => server.getPrimaryService(service_uid))
                .then(service => service.getCharacteristic(characteristic_uid))
                .then(characteristic => {
                    characteristic.writeValueWithResponse(setup_data)
                        .then(response => {
                            characteristic.startNotifications();
                        })
                        .then(() => {
                            characteristic.addEventListener("characteristicvaluechanged", change_handler)
                            output.innerText = "Listening..."
                        })
                })
                .catch(e => { output.innerText = e; });
        }

        var button_state = {
            left_plus: false,
            left_stop: false,
            left_minus: false,
            center: false,
            right_plus: false,
            right_stop: false,
            right_minus: false
        };

        function change_handler(e) {
            const data = e.target.value.buffer ? e.target.value : new DataView(e.target.value);
            let button_state_changed = false;

            if (data.getUint8(0) == 5) {
                if (data.getUint8(2) == 0x08) { // LWP3_MSG_TYPE_HW_NET_CMDS
                    button_state.center = data.getUint8(4) == 1;
                    button_state_changed = true;
                }
            }
            else if (data.getUint8(0) == 7) {
                if (data.getUint8(2) == 0x45) { // LWP3_MSG_TYPE_PORT_VALUE
                    if (data.getUint8(3) == 0) { // LEFT
                        button_state.left_plus = data.getUint8(4) == 1;
                        button_state.left_stop = data.getUint8(5) == 1;
                        button_state.left_minus = data.getUint8(6) == 1;
                        button_state_changed = true;
                    }
                    else if (data.getUint8(3) == 1) { // RIGHT
                        button_state.right_plus = data.getUint8(4) == 1;
                        button_state.right_stop = data.getUint8(5) == 1;
                        button_state.right_minus = data.getUint8(6) == 1;
                        button_state_changed = true;
                    }
                }
            }
            else {
                console.log("Unhandled Event: " + data)
            }

            if (button_state_changed) {
                handleInput(button_state);
            }
        }
    </script>
    <style>
        .button {
            background-color: #404040;
            color: lightgray;
            padding: 15px 32px;
            font-size: 16px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            text-align: center;
            display: inline-block;
            transition: background-color 0.3s ease;
        }
        .button:hover {
            background-color: #606060; 
        }
        .button:active {
            background-color: #808080;
        }
        .output {
            border: 2px solid black;
            margin-top: 5px;
            margin-bottom: 5px;
            display: none;
        }
        canvas {
            display: block;
            border: 1px solid black;
        }

        /***************/

        :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --muted:#9aa4b2;
    --accent:#06b6d4;
    --glass: rgba(255,255,255,0.03);
    --radius:12px;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;color:#e6eef6;background:linear-gradient(180deg,var(--bg),#061022);}
  .app{
    display:grid;
    grid-template-columns:260px 1fr 320px;
    grid-template-rows:64px 1fr 56px;
    gap:18px;
    height:100vh;
    padding:18px;
    box-sizing:border-box;
  }

  header{
    grid-column:1/-1;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    padding:12px 18px;
    background:linear-gradient(180deg,var(--glass),transparent);
    border-radius:var(--radius);
    box-shadow:0 6px 18px rgba(2,6,23,0.6);
    backdrop-filter:blur(6px);
  }
  header .brand{display:flex;align-items:center;gap:12px}
  header .brand .logo{width:40px;height:40px;background:linear-gradient(135deg,var(--accent),#8b5cf6);border-radius:8px;box-shadow:0 4px 14px rgba(11,88,116,0.18)}
  header h1{margin:0;font-size:1.05rem;letter-spacing:0.2px}
  header .meta{color:var(--muted);font-size:.9rem}

  nav.sidebar{
    padding:14px;
    background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);
    border-radius:var(--radius);
    box-shadow:inset 0 1px 0 rgba(255,255,255,0.02);
  }
  .sidebar ul{list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:6px}
  .sidebar a{display:block;padding:10px;border-radius:10px;color:var(--muted);text-decoration:none}
  .sidebar a.active{background:rgba(6,182,212,0.08);color:var(--accent);font-weight:600}

  main{
    padding:14px;
    display:flex;
    gap:14px;
    align-items:stretch;
    background:linear-gradient(180deg,rgba(255,255,255,0.015),transparent);
    border-radius:var(--radius);
  }

  .canvas-panel{
    flex:1;
    min-height:360px;
    display:flex;
    flex-direction:column;
    gap:12px;
    align-items:center;
    justify-content:center;
    padding:18px;
    background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);
    border-radius:10px;
  }

  /* responsive canvas container: maintains aspect and centers canvas */
  .canvas-wrap{
    width:100%;
    max-width:960px;
    aspect-ratio:16/9;
    background:radial-gradient(ellipse at 30% 10%, rgba(255,255,255,0.02), transparent 30%);
    border-radius:8px;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    overflow:hidden;
    box-shadow: 0 10px 30px rgba(2,6,23,0.6);
  }
  canvas#gameCanvas{
    width:100%;
    height:100%;
    display:block;
    background:transparent;
  }

  .controls{
    width:100%;
    display:flex;
    gap:8px;
    justify-content:center;
    align-items:center;
    flex-wrap:wrap;
  }
  .controls button{
    background:transparent;
    border:1px solid rgba(255,255,255,0.06);
    color:var(--muted);
    padding:8px 12px;
    border-radius:8px;
    cursor:pointer;
  }
  .controls button.primary{
    background:linear-gradient(90deg,var(--accent),#8b5cf6);
    color:#041223;border:none;font-weight:600;
  }
  aside.right{
    padding:14px;
    border-radius:var(--radius);
    background:linear-gradient(180deg,rgba(255,255,255,0.015),transparent);
    color:var(--muted);
    font-size:0.95rem;
  }

  footer{
    grid-column:1/-1;
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:10px 14px;
    border-radius:var(--radius);
    background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);
    color:var(--muted);
    font-size:0.875rem;
  }

  /* small screens */
  @media (max-width:980px){
    .app{grid-template-columns:1fr;grid-template-rows:64px 1fr 56px;}
    nav.sidebar, aside.right{display:none}
    main{padding:12px}
  }
    </style>
    <body>
        <div class="app" id="appRoot">
        <header>
            <div class="brand">
            <div class="logo" aria-hidden="true"></div>
            <div>
                <h1>Spinner Game</h1>
                <div class="meta">Play, customize, and compete</div>
            </div>
            </div>
            <div>
            <button id="resetBtn">Reset</button>
            <button id="helpBtn">Help</button>
            </div>
        </header>

        <nav class="sidebar">
            <ul>
            <li><a href="#" class="active">Play</a></li>
            <li><a href="#">Settings</a></li>
            <li><a href="#">Leaderboards</a></li>
            <li><a href="#">About</a></li>
            </ul>
        </nav>

        <main>
            <section class="canvas-panel">
            <div class="canvas-wrap" id="canvasWrap">
                <button id="button" class="button">Connect</button>
                <div id="output" class="output">YOU SHOULD NOT BE SEEING THIS!</div>
                <canvas id="canvas" width="350" height="320"></canvas>
                <button id="debug_button" class="button" style="display: none;">Debug</button>
            </div>
            </section>

            <aside class="right">
            <h3 style="margin-top:0">Game Info</h3>
            <p id="score">Score: 0</p>
            <p id="time">Time: 00:00</p>
            <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03)"/>
            <strong>Tips</strong>
            <ul>
                <li>Click Start to spin.</li>
                <li>Use quality selector for performance.</li>
            </ul>
            </aside>
        </main>
    <footer>
        <div>© Spinner Game</div>
        <div style="color:var(--muted)">Built with canvas • Responsive UI</div>
    </footer>
    </div>
    </body>
    <script>
        // == Spinning Lock Game ==
        // The goal of the game is to set the key pin in the tumbler cut while
        // the tumbler is spinning. The tumbler will spin at a constant speed,
        // and the key pin will be controlled by the player. You can move the
        // key pin clockwise and counterclockwise, but it will only fit in the
        // cut when it's aligned with the cut on the tumbler. You can only
        // insert the key pin when it's aligned with the cut, so you have to
        // time it right as the tumbler spins.

        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        
        let dThetaDegrees = 0;
        let keyPinInCut = false;
        let tumblerSpinning = false;
        const msPerDegree = 10;
        
        const matchTolerance = 15;
        const buttonSize = 60;

        const tumblerCenterX = canvas.width / 2;
        const tumblerCenterY = canvas.height / 2;
        const tumblerInnerRadius = 75
        const tumblerThickness = 60;

        let tumblerKeyPinSpacing = 5;

        let keyPinCenterX = tumblerCenterX;
        let keyPinCenterY = tumblerCenterY;
        const keyPinThickness = 20;
        const keyPinWidthDegrees = 25;
        const keyPinPaddingDegrees = 1;
        let keyPinDegrees = 0;

        let leftKeyDown = false;
        let rightKeyDown = false;
        let upKeyDown = false;
        let downKeyDown = false;

        function degreesToRadians(degrees) {
            return degrees * Math.PI / 180;
        }

        function normalizeDegrees(degrees) {
            return (degrees % 360 + 360) % 360;
        }

        function getTumblerCutDegrees() {
            return 0;
        }

        function drawTumbler() {
            const innerRadius = tumblerInnerRadius;
            const outerRadius = innerRadius + tumblerThickness;
            const startDegrees = normalizeDegrees(dThetaDegrees + keyPinWidthDegrees / 2 - keyPinPaddingDegrees);
            const endDegrees = normalizeDegrees(startDegrees + 360 - keyPinWidthDegrees - 2 * keyPinPaddingDegrees);

            ctx.beginPath();
            ctx.arc(tumblerCenterX, tumblerCenterY, outerRadius, degreesToRadians(startDegrees), degreesToRadians(endDegrees), false);
            ctx.arc(tumblerCenterX, tumblerCenterY, innerRadius, degreesToRadians(endDegrees), degreesToRadians(startDegrees), true);
            ctx.fillStyle = "#FF6A88";
            ctx.fill();
            ctx.closePath();
        }
        
        function drawKeyPin(fillColor) { 
            let keyPinInnerRadius = tumblerInnerRadius + tumblerThickness + tumblerKeyPinSpacing;
            let keyPinOuterRadius = keyPinInnerRadius + keyPinThickness;
            let keyPinMiss = false;

            if (upKeyDown) {
                if (!keyPinInCut) {
                    if (Math.abs(normalizeDegrees(dThetaDegrees - keyPinDegrees)) < matchTolerance) {
                        keyPinInCut = true;
                    }
                    else {
                        keyPinMiss = true;
                    }
                }
                else {
                    keyPinInCut = false;
                }

                upKeyDown = false;
            }

            if (downKeyDown && keyPinInCut) {
                keyPinInCut = false;
                keyPinDegrees = dThetaDegrees
            }

            if (leftKeyDown) {
                keyPinDegrees = normalizeDegrees(keyPinDegrees + 5);
            }
            else if (rightKeyDown) {    
                keyPinDegrees = normalizeDegrees(keyPinDegrees - 5);
            }

            if (keyPinInCut) {
                keyPinOuterRadius = tumblerInnerRadius + tumblerThickness;
                keyPinInnerRadius = keyPinOuterRadius - keyPinThickness;
                
                keyPinDegrees = dThetaDegrees;
            }
            
            startDegrees = normalizeDegrees(keyPinDegrees - keyPinWidthDegrees / 2 - keyPinPaddingDegrees);
            endDegrees = normalizeDegrees(startDegrees + keyPinWidthDegrees - 2 * keyPinPaddingDegrees);

            if (keyPinMiss) {
                fillColor = "red";
            }
            
            ctx.beginPath();
            ctx.arc(keyPinCenterX, keyPinCenterY, keyPinOuterRadius, degreesToRadians(startDegrees), degreesToRadians(endDegrees), false);
            ctx.arc(keyPinCenterX, keyPinCenterY, keyPinInnerRadius, degreesToRadians(endDegrees), degreesToRadians(startDegrees), true);
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.closePath();
        }

        const buttonInfo = {
            x: tumblerCenterX - buttonSize / 2,
            y: tumblerCenterY - buttonSize / 2,
            width: buttonSize,
            height: buttonSize,
            drawBorder: false,
            stopFillColor: "darkred",
            startFillColor: "darkgreen",
            fontColor: "lightgray",
            borderColor: "black"
        };

        function drawButton() {
            if (tumblerSpinning) {
                buttonInfo.fillColor = buttonInfo.stopFillColor;
                buttonInfo.text = "STOP";
            }
            else {
                buttonInfo.fillColor = buttonInfo.startFillColor;
                buttonInfo.text = "START";
            }
            
            ctx.fillStyle = buttonInfo.fillColor;
            ctx.fillRect(buttonInfo.x, buttonInfo.y, buttonInfo.width, buttonInfo.height);

            if (buttonInfo.drawBorder) {
                ctx.lineWidth = 1;
                ctx.strokeStyle = buttonInfo.borderColor;
                ctx.strokeRect(buttonInfo.x, buttonInfo.y, buttonInfo.width, buttonInfo.height);
            }

            ctx.fillStyle = buttonInfo.fontColor;
            ctx.font = "16px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(buttonInfo.text, 1 + buttonInfo.x + buttonInfo.width / 2, 2 + buttonInfo.y + buttonInfo.height / 2);
        }

         function isPointInButton(x, y) {
            return x >= buttonInfo.x && x <= buttonInfo.x + buttonInfo.width &&
                y >= buttonInfo.y && y <= buttonInfo.y + buttonInfo.height; 
        }
    
        function mouseMoveHandler(e) {
            const canvasRect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - canvasRect.left;
            const mouseY = e.clientY - canvasRect.top;

            buttonInfo.drawBorder = isPointInButton(mouseX, mouseY)
        }

        function mouseClickHandler(e) {
            const canvasRect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - canvasRect.left;
            const mouseY = e.clientY - canvasRect.top;

            if (isPointInButton(mouseX, mouseY)) {
                handleButtonClick();
            }
        }

        function handleButtonClick() {
            tumblerSpinning = !tumblerSpinning;
        }

        function drawFrame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawTumbler();
            drawKeyPin(keyPinInCut ? "green" : "black");
            drawButton();
        }

        let startTime;

        function spinTumbler(timeStamp) {
            if (startTime === undefined) {
                startTime = timeStamp;
            }
            
            if (timeStamp - startTime >= msPerDegree) {
                if (tumblerSpinning) {
                    dThetaDegrees = normalizeDegrees(dThetaDegrees + Math.floor((timeStamp - startTime) / msPerDegree));
                }
                startTime = undefined;
            }

            drawFrame();

            requestAnimationFrame(spinTumbler);
        }

        function handleInput(button_state) {
            if (button_state.center) {
                handleButtonClick();
            }

            leftKeyDown = button_state.left_plus;
            rightKeyDown = button_state.left_minus;
            upKeyDown = button_state.left_stop;
        }

        function keyDownHandler(e) {
            if (e.key == "ArrowRight") {
                rightKeyDown = true;
            }
            else if (e.key == "ArrowLeft") {
                leftKeyDown = true;
            }
            else if (e.key == "ArrowUp") {
                upKeyDown = true;
            }
            else if (e.key == "ArrowDown") {
                downKeyDown = true;
            }
        }

        function keyUpHandler(e) {
            if (e.key == "ArrowRight") {
                rightKeyDown = false;
            }
            else if (e.key == "ArrowLeft") {
                leftKeyDown = false;
            }
            else if (e.key == "ArrowUp") {
                upKeyDown = false;
            }
            else if (e.key == "ArrowDown") {
                downKeyDown = false;
            }
        }

        document.addEventListener("keydown", keyDownHandler);
        document.addEventListener("keyup", keyUpHandler);
        document.addEventListener("mousemove", mouseMoveHandler);
        document.addEventListener("click", mouseClickHandler);
        
        spinTumbler();
    </script>
</html>